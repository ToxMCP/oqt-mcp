from __future__ import annotations

import json
from datetime import datetime
from io import BytesIO
from textwrap import wrap

DEFAULT_LEFT = 72
DEFAULT_TOP = 720
LINE_HEIGHT = 16
MAX_CHARS = 90


def _escape(text: str) -> str:
    return text.replace("\\", "\\\\").replace("(", "\\(").replace(")", "\\)")


def _build_content(summary: str, metadata: dict, snapshot: str) -> str:
    lines = ["O-QT MCP Workflow Report", "", f"Generated: {datetime.utcnow().isoformat(timespec='seconds')}Z", ""]
    lines.append("Summary")
    for line in wrap(summary, MAX_CHARS) or [""]:
        lines.append(line)
    lines.append("")
    lines.append("Metadata")
    for key, value in metadata.items():
        lines.append(f"{key}: {value}")
    lines.append("")
    lines.append("Log Snapshot")
    for line in snapshot.splitlines():
        for chunk in wrap(line, MAX_CHARS) or [""]:
            lines.append(chunk)
    if not lines:
        lines.append("")

    y = DEFAULT_TOP
    commands = []
    for line in lines:
        if y < 72:
            commands.append("ET BT")  # ensure text object resets if new page (not implementing multi-page)
            y = DEFAULT_TOP
        escaped = _escape(line)
        commands.append(f"BT /F1 12 Tf {DEFAULT_LEFT} {y} Td ({escaped}) Tj ET")
        y -= LINE_HEIGHT
    return "\n".join(commands)


def generate_pdf_report(log_data: dict) -> BytesIO:
    summary = log_data.get("final_report") or log_data.get("summary") or "No narrative available."
    inputs = log_data.get("inputs") if isinstance(log_data.get("inputs"), dict) else {}
    identifier = inputs.get("identifier") if isinstance(inputs, dict) else None
    identifier = identifier or log_data.get("identifier") or "Unknown"
    metadata = {
        "Identifier": identifier,
        "Generated By": log_data.get("generated_by", "O-QT MCP"),
    }
    serialized = json.dumps(log_data, indent=2)
    if len(serialized) > 4000:
        serialized = serialized[:4000] + "... (truncated)"

    content = _build_content(summary, metadata, serialized)

    objects = []
    offsets = []

    def add_object(obj_str: str) -> None:
        offsets.append(buffer.tell())
        buffer.write(obj_str.encode("utf-8"))

    buffer = BytesIO()
    buffer.write(b"%PDF-1.4\n")
    add_object("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n")
    add_object("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n")
    stream_bytes = content.encode("utf-8")
    add_object(
        f"4 0 obj\n<< /Length {len(stream_bytes)} >>\nstream\n{content}\nendstream\nendobj\n"
    )
    add_object(
        "3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 595 842] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n"
    )
    add_object(
        "5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n"
    )

    xref_pos = buffer.tell()
    buffer.write(b"xref\n0 6\n0000000000 65535 f \n")
    for offset in offsets:
        buffer.write(f"{offset:010d} 00000 n \n".encode("utf-8"))
    buffer.write(b"trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n")
    buffer.write(f"{xref_pos}\n%%EOF".encode("utf-8"))

    buffer.seek(0)
    return buffer
